<?php
/**
 * @file
 * Media Browser Plus - enhanced file management functions.
 */

/**
 * Implements hook_views_api().
 */
function media_browser_plus_views_api() {
  return array(
    'api' => 3,
  );
}

/**
 * Implements hook_menu().
 * @see hook_menu()
 */
function media_browser_plus_menu() {
  $path = drupal_get_path('module', 'media_browser_plus');
  $items['admin/content/file/thumbnailsJSON'] = array(
    'title' => 'Load Media Entities',
    'page callback' => 'media_browser_plus_thumbnailsJSON',
    'page arguments' => array(),
    'access callback' => 'media_browser_plus_access',
    'access arguments' => array('view file'),
    'type' => MENU_CALLBACK,
  );
  $items['admin/content/file/%file/move-to-folder/%taxonomy_term'] = array(
    'title' => 'Load Media Entities',
    'page callback' => 'media_browser_plus_move_file_callback',
    'page arguments' => array(3, 5),
    'access callback' => 'media_browser_plus_access',
    'delivery callback' => 'drupal_json_output',
    'type' => MENU_CALLBACK,
  );
  $items['admin/config/media/media_browser_plus_settings'] = array(
    'title' => 'Media Browser Plus Settings',
    'description' => 'Change the behaviour and layout of the media browser plus UI',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('media_browser_plus_media_settings'),
    'access arguments' => array('administer files'),
    'file path' => $path . '/includes',
    'file' => 'media_browser_plus.admin.inc',
  );

  return $items;
}

/**
 * Implements hook_menu_alter().
 */
function media_browser_plus_menu_alter(&$items) {
  // If enabled replace the default file browser by mbp.
  if (variable_get('media_browser_plus_thumbnails_as_default_browser', TRUE)) {
    $items['admin/content/file/list'] = $items['admin/content/file'];

    $file_title = $items['admin/content/file']['title'];
    $items['admin/content/file'] = $items['admin/content/file/mbp'];
    $items['admin/content/file']['title'] = $file_title;
    $items['admin/content/file/mbp']['type'] = MENU_DEFAULT_LOCAL_TASK;
    $items['admin/content/file/mbp']['weight'] = -1;
  }
}

/**
 * Implements hook_menu_local_tasks_alter().
 */
function media_browser_plus_menu_local_tasks_alter(&$data, $router_item, $root_path) {
  // Add action links on 'admin/content/file/mbp' page.
  // @todo can this be done in the related view?
  if ($root_path == 'admin/content/file/mbp') {
    $item = menu_get_item('file/add');
    if (!empty($item['access'])) {
      $data['actions']['output'][] = array(
        '#theme' => 'menu_local_action',
        '#link' => $item,
        '#weight' => $item['weight'],
      );
    }
    $item = menu_get_item('admin/content/file/import');
    if (!empty($item['access'])) {
      $data['actions']['output'][] = array(
        '#theme' => 'menu_local_action',
        '#link' => $item,
        '#weight' => $item['weight'],
      );
    }
    $item = menu_get_item('admin/structure/taxonomy/media_folders');
    if (!empty($item['access'])) {
      $data['actions']['output'][] = array(
        '#theme' => 'menu_local_action',
        '#link' => $item,
        '#weight' => $item['weight'],
      );
    }
  }
}

/**
 * Implements hook_library().
 */
function media_browser_plus_library() {
  $path = drupal_get_path('module', 'media_browser_plus');
  $libraries['media_browser_plus'] = array(
    'title' => 'Media Browser Plus',
    'version' => '1',
    'js' => array(
      $path . '/js/media_browser_plus.js' => array(),
    ),
    'css' => array(
      $path . '/css/media_browser_plus.views.css' => array(
        'type' => 'file',
        'media' => 'screen',
      ),
    ),
    'dependencies' => array(
      array('system', 'ui.draggable'),
      array('system', 'ui.droppable'),
    ),
  );
  return $libraries;
}

/**
 * Implements hook_action_info().
 */
function media_browser_plus_action_info() {
  // If there's an archiver available provide the download functionality.
  if (count(archiver_get_info())) {
    return array(
      'media_browser_plus_download_action' => array(
        'type' => 'file',
        'label' => t('Download file(s)'),
        'configurable' => TRUE,
        'vbo_configurable' => TRUE,
        'triggers' => array('any'),
      ),
    );
  }
}

/**
 * Configuration form shown to the user before the action gets executed.
 *
 * @todo Replace with proper integration as soon as VBO supports non batch
 * operations.
 */
function media_browser_plus_download_action_form($context, $form_state) {
  // We hijack the whole process here because there's now way yet to skip the
  // batch processing in VBO 3.1.
  $vbo = _views_bulk_operations_get_field($context['view']);
  $selection = _views_bulk_operations_get_selection($vbo, $form_state);

  $archiver_context = $context;
  $archiver_context['destination'] = drupal_tempnam('temporary://', 'mbp');
  $archiver_context['progress']['current'] = count($selection);
  $archiver_context['progress']['total'] = 1;
  $archiver_context['settings']['temporary'] = TRUE;

  $files = file_load_multiple($selection);
  foreach ($files as $file) {
    media_browser_plus_download_action($file, $archiver_context);
    $archiver_context['progress']['total']++;
  }
}

/**
 * Callback for the action.
 */
function media_browser_plus_download_action($file, &$context = array()) {

  // Abuse the existing archiver action. ;)
  // Make sure it never reaches to progress total to avoid storing a file in the
  // database.
  $archiver_context = $context;
  $archiver_context['progress']['total'] = $context['progress']['total'] + 10;
  views_bulk_operations_archive_action($file, $archiver_context);

  if ($context['progress']['current'] == $context['progress']['total']) {
    // Register cleanup function.
    $cleanup_context = &drupal_static('media_browser_plus_download_action', $context);
    drupal_register_shutdown_function('media_browser_plus_download_action_cleanup');

    // Ensure we've the latest file information.
    clearstatcache();
    // Prepare headers.
    $headers['Pragma'] = 'public';
    $headers['Expires'] = '0';
    $headers['Cache-Control'] = 'must-revalidate, post-check=0, pre-check=0';
    $headers['Content-type'] = 'application/zip';
    $headers['Content-Disposition'] = 'attachment; filename=file_download_' . time() . '.zip';
    $headers['Content-length'] = filesize($context['destination']);
    file_transfer($context['destination'], $headers);
  }
}

/**
 * Delete temporary download archive.
 */
function media_browser_plus_download_action_cleanup() {
  $cleanup_context = &drupal_static('media_browser_plus_download_action', array());
  if (isset($cleanup_context['destination'])) {
    drupal_unlink($cleanup_context['destination']);
  }
}

/**
 * Move the file to another folder.
 *
 * @param stdClass $file
 *   The file object to update.
 * @param stdClass $folder
 *   The folder object to use for the file.
 *
 * @return bool
 *   FALSE on error.
 */
function media_browser_plus_move_file_callback($file, $folder) {
  if (empty($file->field_folder[LANGUAGE_NONE][0]['tid']) || $file->field_folder[LANGUAGE_NONE][0]['tid'] != $folder->tid) {
    $file->field_folder[LANGUAGE_NONE] = array(array('tid' => $folder->tid));
    return media_browser_plus_move_file($folder->tid, $file);
  }
  return TRUE;
}

/**
 * Manages access for media browser plus actions.
 *
 * @param string $op
 *   The permission, such as "administer nodes", being checked for.
 *
 * @return bool
 *   TRUE if the user has the permission.
 */
function media_browser_plus_access($op) {
  return (user_access('administer files') || user_access($op));
}

/**
 * Loads and (if $autocreate is set) creates the default media folder object.
 *
 * @param bool $autocreate
 *   Creates the folder if necessary.
 *
 * @return object|FALSE
 *   The folder term or FALSE if not found.
 */
function media_browser_plus_get_media_root_folder($autocreate = FALSE) {
  $root_folder = FALSE;
  $vocabulary = taxonomy_vocabulary_machine_name_load('media_folders');
  if ($vocabulary) {
    // Fetch the media root term.
    $results = taxonomy_get_term_by_name('Media Root', 'media_folders');
    if (!empty($results)) {
      $root_folder = reset($results);
    }
    elseif ($autocreate) {
      $root_folder = new stdClass();
      $root_folder->name = 'Media Root';
      $root_folder->description = 'default media folder';
      $root_folder->vid = $vocabulary->vid;
      $root_folder->weight = '-10';
      // Save (default folder) term.
      taxonomy_term_save($root_folder);
    }
  }
  return $root_folder;
}

/**
 * Construct the path of a media_folder term.
 *
 * Always returns the same path if the filesystem handling is disabled.
 *
 * @param object|NULL $term
 *   Containing term id and term name. If left empty the root folder will be
 *   returned.
 *
 * @return string
 *   The path to the requested folder. Without a trailing slash.
 */
function media_browser_plus_construct_dir_path($term = NULL) {
  $path = '';
  if ($root_folder = variable_get('media_root_folder')) {
    $path = $root_folder;
  }
  if (!variable_get('filesystem_folders', TRUE)) {
    return variable_get('file_default_scheme', 'public') . '://' . trim($path, '/');
  }
  $root_folder_term = media_browser_plus_get_media_root_folder();
  if ($term && $term->tid != $root_folder_term->tid) {
    $parents = array_reverse(taxonomy_get_parents_all($term->tid));
    array_pop($parents);
    if (is_array($parents) && !empty($parents)) {
      foreach ($parents as $parent) {
        if ($parent->tid != $root_folder_term->tid) {
          $path = file_create_filename($parent->name, $path);
        }
      }
    }
    $path = file_create_filename($term->name, $path);
  }
  $path = variable_get('file_default_scheme', 'public') . '://' . trim($path, '/');
  return $path;
}

/**
 * Moves and saves a file.
 *
 * Every managed file that is saved or updated,should pass through this to
 * ensure the filesystem location matches the folder term.
 *
 * @param int $tid
 *   The folder's term id.
 * @param stdClass $file
 *   The file object.
 * @param int $replace
 *   Replace behavior when the destination file already exists.
 *
 * @return bool
 *   TRUE on success.
 */
function media_browser_plus_move_file($tid, $file, $replace = FILE_EXISTS_RENAME) {
  $local_stream_wrappers = media_get_local_stream_wrappers();
  $scheme = file_uri_scheme($file->uri);

  // Don't change the uri for non-local files.
  if (!isset($local_stream_wrappers[$scheme])) {
    file_save($file);
  }
  else {
    // Media translation module does need this since it allows the creation of
    // file references which shouldn't move the referenced file itself when
    // moved. See http://drupal.org/node/1331818 for details.
    if (module_exists('media_translation') && media_translation_is_virtual_file($file->fid)) {
      file_save($file);
      return TRUE;
    }
    $folder = taxonomy_term_load($tid);
    $path = media_browser_plus_construct_dir_path($folder);
    file_prepare_directory($path, FILE_CREATE_DIRECTORY | FILE_MODIFY_PERMISSIONS);
    return file_move($file, $path, $replace);
  }
  return TRUE;
}

/**
 * Implements hook_taxonomy_term_presave().
 *
 * @see media_browser_plus_taxonomy_term_update()
 */
function media_browser_plus_taxonomy_term_presave($term) {
  // Figure out if this is a folder term and if so store the current file path
  // for further processing in media_browser_plus_taxonomy_term_update().
  $vocabulary = taxonomy_vocabulary_machine_name_load('media_folders');
  if (!empty($vocabulary) && $term->vid == $vocabulary->vid) {
    // A subfolder term is always child of the root folder.
    if (empty($term->parent[0])) {
      $root_folder = media_browser_plus_get_media_root_folder();
      $term->parent = array($root_folder->tid);
    }
    // A folder term can just have one parent.
    if (count($term->parent) > 1) {
      $term->parent = array(reset($term->parent));
    }
    // Actions if this is an existing term.
    if (!empty($term->tid)) {
      // Store current path the check later if the folder was moved.
      $term->media_browser_plus_original_path = media_browser_plus_construct_dir_path($term);
    }
  }
}

/**
 * Implements hook_taxonomy_term_insert().
 */
function media_browser_plus_taxonomy_term_insert($term) {
  if ($term->vocabulary_machine_name == 'media_folders') {
    // Prepare path for new folder terms.
    $dir = media_browser_plus_construct_dir_path($term);
    if (file_prepare_directory($dir, FILE_CREATE_DIRECTORY | FILE_MODIFY_PERMISSIONS)) {
      drupal_set_message(t('Folder %term_name created successfully', array('%term_name' => $term->name)));
    }
    else {
      drupal_set_message(t('Folder %term_name created successfully as term but failed to create as physical folder.Please do it manually', array('%term_name' => $term->name)), 'warning');
    }
  }
}

/**
 * Implements hook_taxonomy_term_update().
 *
 * @see media_browser_plus_taxonomy_term_presave()
 */
function media_browser_plus_taxonomy_term_update($term) {
  // Check if the folder term was moved. Only folder terms have this property.
  if (!empty($term->media_browser_plus_original_path)) {
    $destination = media_browser_plus_construct_dir_path($term);
    if ($term->media_browser_plus_original_path != $destination) {
      module_load_include('inc', 'media_browser_plus', '/includes/media_browser_plus.folders');
      // Prepare batch to move folder and files.
      $batch = array(
        'title' => t('Updating file locations'),
        'operations' => media_browser_plus_move_subfolder($term, $term->media_browser_plus_original_path, $destination),
        'file' => drupal_get_path('module', 'media_browser_plus') . '/includes/media_browser_plus.folders.inc',
      );
      // If necessary start the batch to update the folder structure.
      if (!empty($batch['operations'])) {
        batch_set($batch);
      }
    }
  }
}

/**
 * Implements hook_taxonomy_term_delete().
 */
function media_browser_plus_taxonomy_term_delete($term) {
  // Figure out if this is a folder term and if so handle the related files.
  $vocabulary = taxonomy_vocabulary_machine_name_load('media_folders');
  if (!empty($vocabulary) && $term->vid == $vocabulary->vid) {
    // Create an array of all the folders to handle.
    $folders = array(
      '0:' . $term->tid => $term,
    );
    // Fetch all sub-folders.
    $tree = taxonomy_get_tree($term->vid, $term->tid);
    foreach ($tree as $subterm) {
      $folders[($subterm->depth + 1) . ':' . $subterm->tid] = $subterm;
    }
    // Ensure the order for processing is right.
    krsort($folders);

    foreach ($folders as $folder) {
      // Fetch all files from the folder.
      $file_query = new EntityFieldQuery();
      $files = $file_query
        ->entityCondition('entity_type', 'file')
        ->fieldCondition('field_folder', 'tid', $folder->tid)
        ->execute();
      $all_files_deleted = TRUE;
      // If there are files, delete them.
      if (!empty($files['file'])) {
        $files = file_load_multiple(array_keys($files['file']));
        foreach ($files as $file) {
          if (!file_delete($file)) {
            $all_files_deleted = FALSE;
          }
        }
      }
      // Also delete the folder when it's empty.
      if ($all_files_deleted) {
        $folder_path = media_browser_plus_construct_dir_path($folder);
        if (!@drupal_rmdir($folder_path)) {
          drupal_set_message(t('Unable to delete the folder (!path) on the disk', array('!path' => $folder_path)), 'error');
        }
      }
    }
  }
}

/**
 * Implements hook_form_FORM_ID_alter().
 *
 * This is necessary since altering the hierarchy or weight of terms in the
 * overview won't trigger any term hooks *blargh* :|
 */
function media_browser_plus_form_taxonomy_overview_terms_alter(&$form, &$form_state, $vocabulary) {
  if (variable_get('filesystem_folders', TRUE) && $form['#vocabulary']->machine_name == 'media_folders') {
    $form['#validate'][] = 'media_browser_plus_form_taxonomy_overview_terms_validate';
    $form['#submit'][] = 'media_browser_plus_form_taxonomy_overview_terms_submit';
  }
}

/**
 * Validation handler for the taxonomy term overview list.
 *
 * This is necessary since altering the hierarchy or weight of terms in the
 * overview won't trigger any term hooks *blargh* :|
 */
function media_browser_plus_form_taxonomy_overview_terms_validate(&$form, &$form_state) {
  $vocabulary = $form['#vocabulary'];
  $tree = taxonomy_get_tree($vocabulary->vid);
  foreach ($tree as $term) {
    $form_state['#mbp_original_paths'][$term->tid] = media_browser_plus_construct_dir_path($term);
  }
}

/**
 * Submit handler for the taxonomy term overview list.
 *
 * This is necessary since altering the hierarchy or weight of terms in the
 * overview won't trigger any term hooks *blargh* :|
 */
function media_browser_plus_form_taxonomy_overview_terms_submit(&$form, &$form_state) {
  module_load_include('inc', 'media_browser_plus', 'includes/media_browser_plus.folders');
  $vocabulary = $form['#vocabulary'];
  taxonomy_terms_static_reset();
  $root_folder = media_browser_plus_get_media_root_folder();
  $tree = taxonomy_get_tree($vocabulary->vid);

  // Prepare batch.
  $batch = array(
    'title' => t('Updating Media'),
    'operations' => array(),
    'finished' => 'media_browser_plus_update_folder_hierarchy_batch_complete',
    'file' => drupal_get_path('module', 'media_browser_plus') . '/includes/media_browser_plus.folders.inc',
  );
  foreach ($tree as $term) {
    // Deal only with subfolders.
    if ($term->tid != $root_folder->tid) {
      // A subfolder term is always child of the root folder.
      if (empty($term->parents[0])) {
        // The presave hook will take care of fixing this.
        taxonomy_term_save($term);
      }
      $path = media_browser_plus_construct_dir_path($term);
      if ($form_state['#mbp_original_paths'][$term->tid] != $path) {
        $batch['operations'] = array_merge($batch['operations'], media_browser_plus_move_subfolder($term, $form_state['#mbp_original_paths'][$term->tid], $path));
      }
    }
  }
  // If necessary start the batch to update the structure.
  if (!empty($batch['operations'])) {
    batch_set($batch);
  }
}

/**
 * Batch process finish callback for updating the folder hierarchy.
 */
function media_browser_plus_update_folder_hierarchy_batch_complete($success, $results, $operations) {
  if ($success) {
    drupal_set_message(t('Successfully updated all folders'));
  }
  else {
    drupal_set_message(t('Error while updating folder structure'), 'error');
  }
}
