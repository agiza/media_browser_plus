<?php
/**
 * @file
 * Adds fields to the media browser forms for better UX
 */

define('MEDIA_ENTITY_ACCESS_IGNORE', 10);
define('MEDIA_ENTITY_ACCESS_DENY', 20);
define('MEDIA_ENTITY_ACCESS_ALLOW', 30);

/**
 * Implements hook_views_api().
 */
function media_browser_plus_views_api() {
  return array(
    'api' => 3,
    // 'path' => drupal_get_path('module', 'media_browser_plus') . '/views',
  );
}

/**
 * Puts all selected media items into a zip archive and sends it as download.
 *
 * @TODO: check for internet sources etc. Only local files should be parsed.
 *
 * @param array $form
 *   The form structure.
 * @param array $form_state
 *   The form state.
 */
function media_browser_plus_download_images_submit($form, &$form_state) {
  if (isset($form_state['input']['selected_media']) && media_browser_plus_access('download media')) {
    $ids = array_keys($form_state['input']['selected_media']);
    // Only load those.
    $conditions[] = array('property' => array('fid', array($ids), 'IN'));
    $media_entities = media_browser_plus_load_multiple(array(
      'conditions' => $conditions,
      'apply_filter' => FALSE,
      'paging' => FALSE,
    ));

    // If possible avoid duplicate compression.
    if (function_exists('apache_setenv')) {
      @apache_setenv('no-gzip', '1');
    }

    // Create archive.
    $name = 'media-download-' . md5(microtime() . uniqid());
    $zip_file = '/tmp/' . $name . '.zip';
    $zip = new ZipArchive();
    $res = $zip->open($zip_file, ZipArchive::CREATE);
    if ($res === TRUE && count($media_entities->results)) {
      foreach ($media_entities->results as $media) {
        $zip->addFile(drupal_realpath($media->uri), $media->filename);
      }
      $zip->close();
      header('Cache-Control: public');
      header('Pragma: public');
      header('Expires: 0');
      header('Cache-Control: must-revalidate, post-check=0, pre-check=0');
      header('Cache-Control: public');
      // header('Content-Description: File Transfer');
      header('Content-type: application/zip');
      header('Content-Disposition: attachment; filename=' . $zip_file);
      // header('Content-Transfer-Encoding: binary');
      header('Content-length: ' . filesize($zip_file));
      readfile($zip_file);
      drupal_unlink($zip_file);
      die();
    }
    else {
      drupal_set_message(t('Failed to create download archive'), 'error');
    }
  }
}


/**
 * Called by the JS fronted (ajax) to change the folder of a media object.
 */
function media_browser_plus_change_folder($form, &$form_state) {
  if (!isset($form_state['input']['media'])) {
    // @fixme Decide: die() or return.
    die('');
    return $form;
  }
  // Parse values.
  $folder = (int) (str_replace('folder_load_', '', $form_state['input']['folder']));
  $media_id = (int) (str_replace('edit-files-', '', $form_state['input']['media']));
  if (!$media_id) {
    // @fixme Decide: die() or return.
    die('');
    return $form;
  }
  $media = file_load($media_id);
  // Apply new folder.
  if (isset($media->field_folder[LANGUAGE_NONE][0]['tid'])) {
    $media->field_folder[LANGUAGE_NONE][0]['tid'] = $folder;
  }
  else {
    $media->field_folder = array(LANGUAGE_NONE => array(array('tid' => $folder)));
  }

  // Save changes.
  media_browser_plus_move_file($folder, $media);

  // @fixme Decide: die() or return.
  die('');
  return $form;
}

/**
 * Called by the JS fronted (ajax) to get the media list for a given folder.
 */
function media_browser_plus_thumbnailsJSON() {
  if (isset($_GET['folder'])) {
    $folder = (int) (str_replace('folder_load_', '', $_GET['folder']));
    // Create conditions.
    $conditions = array();
    // Check for filter set by library.
    if (isset($_GET['filter'])) {
      $filter = drupal_json_decode($_GET['filter']);
      // Bugfix - $conditions = $filter;
      foreach ($filter as $key => $value) {
        // Checking each filter.
        $valid = TRUE;
        foreach ($value as $type => $params) {
          foreach ($params as $param) {
            if (is_array($param)) {
              $valid = !empty($param);
              foreach ($param as $media_type) {
                if (strlen(trim($media_type)) == 0) {
                  $valid = FALSE;
                  break;
                }
              }
            }
            else {
              if (strlen(trim($param)) == 0) {
                $valid = FALSE;
                break;
              }
            }
          }
        }
        if ($valid) {
          $conditions[] = $value;
        }
      }
    }
    // More conditions.
    if ($folder) {
      $conditions[] = array(
        'field' => array('field_folder', 'tid', array($folder), 'IN'),
      );
    }
    elseif ($folder === 0) {
      // Get unsorted files. We can't use EFQ conditions because the field
      // tables are joined using inner join, what excludes unsorted files from
      // the whole query at all. Thus fetch the fids of the unsorted fields and
      // use this as condition.
      $query = db_select('file_managed')
        ->fields('file_managed', array('fid', 'fid'))
        ->condition('uri', db_like('temporary://') . '%', 'NOT LIKE')
        ->isNull('entity_id');
      $query->leftJoin('field_data_field_folder', 'folder', "entity_type = 'file' AND entity_id = file_managed.fid");
      $result = $query->execute()->fetchAll(PDO::FETCH_KEY_PAIR);
      $conditions[] = array(
        'property' => array('fid', $result, 'IN'),
      );
    }
    $order = array(array('property' => array('fid', 'DESC')));
    $media_entities = media_browser_plus_load_multiple(array('conditions' => $conditions, 'order' => $order));
    module_load_include('inc', 'media', 'includes/media.browser');
    foreach ($media_entities->results as $media) {
      media_browser_build_media_item($media);
    }
    $output = array(
      'media' => array_values($media_entities->results),
      'folder_loaded' => 'folder_load_' . $folder,
      'overall_count' => $media_entities->overall_count,
    );
    drupal_json_output($output);
    die();
  }
}

/**
 * Implements hook_menu().
 */
function media_browser_plus_menu() {
  $items['admin/content/file/thumbnailsJSON'] = array(
    'title' => 'Load Media Entities',
    'page callback' => 'media_browser_plus_thumbnailsJSON',
    'page arguments' => array(),
    'access callback' => 'media_browser_plus_access',
    'access arguments' => array('view file'),
    'type' => MENU_CALLBACK,
  );
  $items['admin/content/file/%file/move-to-folder/%taxonomy_term'] = array(
    'title' => 'Load Media Entities',
    'page callback' => 'media_browser_plus_move_file_to_folder',
    'page arguments' => array(3, 5),
    'access callback' => 'media_browser_plus_access',
    'delivery callback' => 'drupal_json_output',
    'type' => MENU_CALLBACK,
  );
  $items['admin/config/media/media_browser_plus_settings'] = array(
    'title' => 'Media Browser Plus Settings',
    'description' => 'Change the behaviour and layout of the media browser plus UI',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('media_browser_plus_media_settings'),
    'access arguments' => array('administer files'),
  );
  $items['admin/content/file/%file/preview'] = array(
    'title' => 'Preview Media',
    'description' => 'Preview Media Item',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('media_browser_plus_media_preview', 3),
    'access callback' => 'media_browser_plus_access',
    'access arguments' => array('preview media'),
    'file' => 'includes/media_browser_plus.pages.inc',
  );
  return $items;
}


/**
 * Implements hook_permission().
 */
function media_browser_plus_permission() {
  return array(
    'media grid view' => array(
      'title' => t('Grid View'),
      'description' => t('Allow users to use the grid view.'),
    ),
    'media list view' => array(
      'title' => t('List View'),
      'description' => t('Allow users to use the list view.'),
    ),
    'access media backend' => array(
      'title' => t('Access media backend'),
      'description' => t('Allow user to access the media backend according to their privileges.'),
    ),
    'upload media' => array(
      'title' => t('Upload media'),
      'description' => t('Allow user to add media.'),
    ),
    'download files' => array(
      'title' => t('Download Files'),
      'description' => t('Allows the user to download the original file items.'),
    ),
    'filter media' => array(
      'title' => t('Filter Media'),
      'description' => t('Allows the user to filter the displayed media in the backend.'),
    ),
    'administer media folders' => array(
      'title' => t('Administer Media Folders'),
      // @TODO better description
      'description' => t('Allows the user to add, edite, delete and resort media folders.'),
    ),
    'preview media' => array(
      'title' => t('Preview media'),
      // @TODO better description
      'description' => t('Allows the user to view a configurable preview of the original media item.'),
    ),
  );
}

/**
 * Implements hook_library().
 */
function media_browser_plus_library() {
  $path = drupal_get_path('module', 'media_browser_plus');
  $libraries['media_browser_plus'] = array(
    'title' => 'Media Browser Plus',
    'version' => '1',
    'js' => array(
      $path . '/js/media_browser_plus.js' => array(),
    ),
    'css' => array(
      $path . '/css/media_browser_plus.views.css' => array(
        'type' => 'file',
        'media' => 'screen',
      ),
    ),
    'dependencies' => array(
      array('system', 'ui.draggable'),
      array('system', 'ui.droppable'),
    ),
  );
  return $libraries;
}

/**
 * Move the file to another folder.
 *
 * @param stdClass $file
 *   The file object to update.
 * @param stdClass $folder
 *   The folder object to use for the file.
 *
 * @return bool
 *   FALSE on error.
 */
function media_browser_plus_move_file_to_folder($file, $folder) {
  if (empty($file->field_folder[LANGUAGE_NONE][0]['tid']) || $file->field_folder[LANGUAGE_NONE][0]['tid'] != $folder->tid) {
    $file->field_folder[LANGUAGE_NONE] = array(array('tid' => $folder->tid));
    file_save($file);
  }
  return TRUE;
}

/**
 * Checks if the user has the permission to download a file.
 *
 * @todo: this function may be obsolete in 2.x
 *
 * @param $field
 * @param string $entity_type
 *   The entity type.
 * @param string $entity
 *   Then entity.
 */
function media_browser_plus_file_download_access($field, $entity_type, $entity) {
  // Only check against media entities.
  if ($entity_type == 'file') {
    // Check for media admin AND return true if found.
    return file_acces('view', $entity);
    // return media_browser_plus_media_access($entity);
  }
}

/**
 * Checks access to a given media entity.
 *
 * @todo: this function may be obsolete in 2.x
 *
 * @param object $media_entity
 */
function media_browser_plus_media_access($media_entity) {
  if (media_browser_plus_access('administer files')) {
    return TRUE;
  }
  // Start with ACCESS_ALLOW - by default media items are fully accessible.
  $access = MEDIA_ENTITY_ACCESS_ALLOW;
  // Collect all modules implementing hook_media_entity_access.
  foreach (module_implements('media_entity_access') as $module) {
    // And invoke the hook.
    $return = module_invoke($module, 'media_entity_access', $media_entity);
    // If no ALLOW or DENY was returned we assume IGNORE and check the next.
    if ($return != MEDIA_ENTITY_ACCESS_ALLOW && $return != MEDIA_ENTITY_ACCESS_DENY) {
      continue;
    }
    // If we have a DENY we can return a complete false here.
    if ($return === MEDIA_ENTITY_ACCESS_DENY) {
      return FALSE;
    }
    // Otherwise it is an ALLOW and we save it.
    $access = MEDIA_ENTITY_ACCESS_ALLOW;
  }
  // Check if we had one allow.
  return ($access === MEDIA_ENTITY_ACCESS_ALLOW);
}

/**
 * Revokes the general 'view media' == 'download media' access rule.
 * @todo: this function may be obsolete in 2.x
 */
function media_browser_plus_file_download_access_alter(&$grants, $field, $entity_type, $entity = NULL) {
  if ($entity_type == 'file') {
    unset($grants['file']);
  }
}

/**
 * Implements hook_media_operations().
 */
function media_browser_plus_media_operations() {
  return array(
    'edit_multiple' => array(
      'label' => t('Edit'),
      'callback' => NULL,
      'redirect' => 'admin/content/file/edit_multiple/%fids',
    ),
  );
}

/**
 * Manages access for media browser plus actions.
 *
 * @param string $op
 *   The permission, such as "administer nodes", being checked for.
 *
 * @return bool
 *   TRUE if the user has the permission.
 */
function media_browser_plus_access($op) {
  return (user_access('administer files') || user_access($op));
}

/**
 * Checks for unsorted (i.e. media not in folders) media.
 */
function _media_browser_plus_has_unsorted_media() {

  // EFQ doesn't work because the field table is used as base table and an inner
  // join is used?!
  // $query = new EntityFieldQuery('file');
  // $result = $query
  //   ->entityCondition('entity_type', 'file')
  //   ->propertyCondition('status', 1)
  //   ->fieldCondition('field_folder', 'tid', '', 'IS NULL')
  //   ->range(0, 1)
  //   ->execute();
  //
  // In favor of not unnecessarily loading file entities we use a raw query.
  // *eeeewwh*!
  $query = db_select('file_managed')
    ->fields('file_managed', array('fid'))
    ->condition('uri', db_like('temporary://') . '%', 'NOT LIKE')
    ->isNull('entity_id')
    ->range(0, 1);
  $query->leftJoin('field_data_field_folder', 'folder', "entity_type = 'file' AND entity_id = file_managed.fid");
  $result = $query->execute()->fetchCol();

  return !empty($result);
}

/**
 * Loads media entities and allows filtering, sorting and paging.
 *
 * @param array $variables
 *   Holds an array with the following optional parameters
 * $ids
 *   one dimensional array of entity_ids
 * $conditions
 *   multidemsional array build like this:
 *   array(
 *     array('entity' => array('comlumn', 'value', 'condition')),
 *     array('property' => array('comlumn', 'value', 'condition')),
 *     array('field' => array('field_name', 'comlumn', 'value', 'condition')),
 *   )
 * $order
 *   multidemsional array build like this:
 *   array(array('entity' => array('comlumn', 'direction')),
 *         array('property' => array('comlumn', 'direction')),
 *         array('field' => array('comlumn', 'direction')))
 * $header
 *   table header used for sorting
 * $per_page
 *   items per page
 */
function media_browser_plus_load_multiple($variables) {
  // Set up default parameter.
  $params = array(
    'ids' => array(),
    'conditions' => array(),
    'order' => array(),
    'header' => array(),
    'page' => -1,
    'per_page' => variable_get('media_media_per_page', 30),
    'paging' => TRUE,
    'ids_only' => FALSE,
    'count_only' => FALSE,
    'apply_filter' => TRUE,
  );
  // Override defaults.
  // @todo Is this loop really necessary. Something like
  // $params = $variables + $params; should work too, right?
  foreach ($variables as $key => $value) {
    if (isset($params[$key])) {
      $params[$key] = &$variables[$key];
    }
  }
  if ($params['apply_filter'] && isset($_SESSION['media-filter'])) {
    if (strlen($_SESSION['media-filter']['filename'])) {
      $params['conditions'][] = array(
        'property' => array(
          'filename',
          '%' . $_SESSION['media-filter']['filename'] . '%',
          'LIKE',
        ),
      );
    }
    if (count($_SESSION['media-filter']['type'])) {
      $params['conditions'][] = array(
        'property' => array(
          'type',
          explode(',', $_SESSION['media-filter']['type']),
          'IN',
        ),
      );
    }
    if (count($_SESSION['media-filter']['field_folder'])) {
      $params['conditions'][] = array(
        'field' => array(
          'field_folder',
          'tid',
          $_SESSION['media-filter']['field_folder'],
          'IN',
        ),
      );
    }
    if (count($_SESSION['media-filter']['field_tags'])) {
      foreach ($_SESSION['media-filter']['field_tags'] as $tag_id) {
        $params['conditions'][] = array(
          'field' => array('field_tags', 'tid', $tag_id, '='),
        );
      }
    }
  }
  // Do not list temporary files.
  foreach (array_keys(media_get_hidden_stream_wrappers()) as $name) {
    $params['conditions'][] = array(
      'property' => array('uri', $name . '%', 'NOT LIKE'),
    );
  }
  // Allow other modules to add/alter conditions.
  foreach (module_implements('media_access_conditions') as $module) {
    $params['conditions'] = array_merge(module_invoke($module, 'media_access_conditions'), $params['conditions']);
  }
  $query = new EntityFieldQuery();
  // Set entity type to media.
  $query->entityCondition('entity_type', 'file');
  // EntityFieldQuery shouldn't check access against node_access.
  $query->addTag('DANGEROUS_ACCESS_CHECK_OPT_OUT');
  // Parse ids if any have been passed.
  if (count($params['ids'])) {
    $query->entityCondition('entity_id', $params['ids'], 'IN');
  }
  // Check for table header.
  if (count($params['header'])) {
    $query->tableSort($params['header']);
  }
  // Parse conditions.
  foreach ($params['conditions'] as $condition) {
    // Look what type we have.
    $condition_keys = array_keys($condition);
    switch (array_pop($condition_keys)) {
      case 'entity':
        $query->entityCondition(
          $condition['entity'][0],
          $condition['entity'][1],
          $condition['entity'][2]
        );
        break;

      case 'property':
        $query->propertyCondition(
          $condition['property'][0],
          $condition['property'][1],
          $condition['property'][2]
        );
        break;

      case 'field':
        $query->fieldCondition(
          $condition['field'][0],
          $condition['field'][1],
          $condition['field'][2],
          $condition['field'][3]
        );
        break;

    }
  }
  // Parse order array.
  foreach ($params['order'] as $condition) {
    // Look what type we have.
    $condition_keys = array_keys($condition);
    switch (array_pop($condition_keys)) {
      case 'entity':
        $query->entityOrderBy(
          $condition['entity'][0],
          $condition['entity'][1]
        );
        break;

      case 'property':
        $query->propertyOrderBy(
          $condition['property'][0],
          $condition['property'][1]
        );
        break;

      case 'field':
        $query->fieldOrderBy(
          $condition['field'][0],
          $condition['field'][1],
          $condition['field'][2]
        );
        break;

    }
  }
  // Prepare result object.
  $res_object = new stdClass();
  if ($params['paging'] && !$params['count_only']) {
    // Doing a separate count query here, because including the internal pager
    // doesn't work but seems the only way to get a total result count.
    $count = clone $query;
    $count->pager();
    $count->execute();
    $res_object->overall_count = $count->pager['total'];
    // Using range here, because as said above the internal pager seems to be
    // bugged.
    $page = $params['page'];
    if ($page == -1) {
      $page = isset($_REQUEST['page']) ? $_REQUEST['page'] : 0;
    }
    $query->range($page * $params['per_page'], $params['per_page']);
    // Adding the addition result fields.
    $res_object->page = $page;
    $res_object->pages = ceil($res_object->overall_count / variable_get('media_media_per_page', 30));
    $res_object->per_page = $params['per_page'];
  }
  // Count only query.
  if ($params['count_only']) {
    $query->pager();
    $query->execute();
    return $query->pager['total'];
  }
  $res_object->results = array();
  // Execute query and load results.
  $result = $query->execute();
  if (!empty($result['file'])) {
    $res_object->results = $params['ids_only'] ? array_keys($result['file']) :
      entity_load('file', array_keys($result['file']));
  }
  return $res_object;
}

/**
 * Looks if a filter is active and filters the folders accordingly.
 *
 * @param array $folders
 *   The folders to filter.
 *
 * @return array
 *   The list with the filtered folders.
 */
function _media_browser_plus_filter_folders($folders) {
  // No filter active, return unchanged $folders array.
  $filtered_folders = $folders;
  if (isset($_SESSION['media-filter'])) {
    $folder_filtered = array();
    // Look through the tree and add elements that match filter.
    foreach ($folders as $item) {
      if (in_array($item->tid, $_SESSION['media-filter']['field_folder'])) {
        $folder_filtered[] = $item;
      }
    }
    $filtered_folders = $folder_filtered;
  }
  $filtered_folders = _media_browser_plus_filter_folder_access($filtered_folders);
  return $filtered_folders;
}

/**
 * @todo Document what this function does.
 *
 * @param array $folders
 *   The folders to scan.
 *
 * @return array
 *   List with the accessible folders.
 */
function _media_browser_plus_filter_folder_access($folders) {
  $temp_folders = $folders;
  $filtered_folders = array();
  foreach ($temp_folders as $item) {
    $access = TRUE;
    foreach (module_implements('media_folder_access') as $module) {
      $access = module_invoke($module, 'media_folder_access', $item);
      if ($access === FALSE) {
        break;
      }
      else {
        $access = TRUE;
      }
    }
    if ($access) {
      $filtered_folders[] = $item;
    }
  }
  return $filtered_folders;
}

/**
 * Creates the media browser plus settings form.
 */
function media_browser_plus_media_settings($form, &$form_state = array()) {
  $form = array(
    'media_per_page' => array(
      '#type' => 'textfield',
      '#title' => t('Media Items per page'),
      '#description' => t('Insert a number higher than one for the amount of media items displayed per page.'),
      '#default_value' => variable_get('media_media_per_page', 30),
      '#maxlength' => 4,
      '#required' => TRUE,
    ),
    'grid_window_height' => array(
      '#type' => 'textfield',
      '#title' => t('Grind Window Height'),
      '#default_value' => variable_get('media_grid_window_height', 400),
      '#description' => t('Set a maximum height of pixels for the media grid view.'),
      '#maxlength' => 4,
      '#required' => TRUE,
    ),
    'page_items_per_page' => array(
      '#type' => 'textfield',
      '#title' => t('Page Items per page'),
      '#default_value' => variable_get('media_page_items_per_page'),
      '#description' => t('Set how many page items you want in the paging navigation of each page.'),
      '#maxlength' => 4,
      '#required' => TRUE,
    ),
    'max_filesize' => array(
      '#type' => 'textfield',
      '#title' => t('Upload Maximum Filesize'),
      '#default_value' => media_variable_get('max_filesize'),
      '#description' => t('Standard unit is bytes and therefore can be left out. Otherwise use "NUMBER UNIT"'),
      '#maxlength' => 20,
      '#required' => TRUE,
    ),
    'root_folder' => array(
      '#type' => 'textfield',
      '#title' => t('Media Root folder'),
      '#default_value' => variable_get('media_root_folder'),
      '#description' => t("The root folder for files handled by the media module. <strong>Attention: Changing this will move all existing files in the file system too!</strong>"),
    ),
    'media_browser_plus_thumbnails_as_default_browser' => array(
      '#type' => 'checkbox',
      '#title' => t('Use thumbnails view as default.'),
      '#description' => t('If enabled the thumbnails view will displayed when accessing "admin/content/file".'),
      '#default_value' => variable_get('media_browser_plus_thumbnails_as_default_browser', TRUE),
    ),
  );

  $form['actions'] = array('#type' => 'actions');
  $form['actions']['submit'] = array('#type' => 'submit', '#value' => t('Save Changes'));
  return $form;

}

/**
 * Saves the entered settings.
 */
function media_browser_plus_media_settings_submit($form, &$form_state) {
  // Change settings.
  variable_set('media_media_per_page', (int) $form_state['values']['media_per_page']);
  variable_set('media_grid_window_height', (int) $form_state['values']['grid_window_height']);
  variable_set('media_page_items_per_page', (int) $form_state['values']['page_items_per_page']);
  media_variable_set('max_filesize', trim($form_state['values']['max_filesize']));

  // Check if the root folder was changed.
  $old_root = variable_get('media_root_folder');
  $new_root = trim($form_state['values']['root_folder'], '/');
  // Move the files to the new root folder if necessary.
  if ($old_root != $new_root) {
    // Load folder handling functions.
    module_load_include('inc', 'media_browser_plus', 'includes/media_browser_plus.folders');
    media_browser_plus_move_root_folder($old_root, $new_root);
  }

  // Notify user.
  drupal_set_message(t('Media Browser Plus Settings changed successfully'));
}

/**
 * Validates the settings.
 */
function media_browser_plus_media_settings_validate($form, &$form_state) {
  // Validate settings.
  $value = (int) $form_state['values']['media_per_page'];
  if ($value <= 0) {
    form_set_error('Media Settings', t('Illegal value for "Media Items per page"'));
  }
  $value = (int) $form_state['values']['grid_window_height'];
  if ($value <= 100) {
    form_set_error('Media Settings', t('Illegal value for "Grind Window Height"'));
  }
  $value = (int) $form_state['values']['page_items_per_page'];
  if ($value <= 2) {
    form_set_error('Media Settings', t('Illegal value for "Page Items per page"'));
  }
  $value = parse_size(trim($form_state['values']['max_filesize']));
  if ($value === 0) {
    form_set_error('Media Settings', t('Illegal value for "Upload Maximum Filesize"'));
  }
}

/**
 * Implements hook_field_attach_presave().
 *
 * Makes sure all media are in a folder.
 */
function media_browser_plus_field_attach_presave($entity_type, $entity) {
  if ($entity_type != 'file') {
    return;
  }
  // Look for folder and set default if none found
  // $media->field_folder[LANGUAGE_NONE] = array(array('tid' => $form_state['values']['field_folder']));
  if (!isset($entity->field_folder) ||
    !isset($entity->field_folder[LANGUAGE_NONE]) ||
    !count($entity->field_folder[LANGUAGE_NONE]) ||
    !isset($entity->field_folder[LANGUAGE_NONE][0]['tid']) ||
    (int) $entity->field_folder[LANGUAGE_NONE][0]['tid'] == 0) {

    // sSt default folder is no folder or incorrect value.
    $root = media_browser_plus_get_media_root_folder();
    $entity->field_folder = array();
    $entity->field_folder[LANGUAGE_NONE] = array(array('tid' => $root->tid));
  }
}

/**
 * Check if a given folder has media in it (does include current filter).
 *
 * @param int $folder_id
 *   Id of the folder to check.
 *
 * @return bool
 *  TRUE if the folder is empty.
 */
function _media_browser_plus_folder_is_empty($folder_id) {
  // Save paging values.
  $gp = isset($_GET['page']) ? $_GET['page'] : NULL;
  $pp = isset($_POST['page']) ? $_POST['page'] : NULL;
  // Set media condition.
  $condition = array(
    array('field' => array('field_folder', 'tid', array($folder_id), 'IN')),
  );
  $variables = array(
    'conditions' => $condition,
    'per_page' => 1,
    'ids_only' => TRUE,
  );
  $media = media_browser_plus_load_multiple($variables);
  // Restore paging values if necessary.
  if ($gp) {
    $_GET['page'] = $gp;
  }
  if ($pp) {
    $_POST['page'] = $pp;
  }
  // Check if media has been found in the folder.
  return empty($media->overall_count);
}

/**
 * Loads and (if $autocreate is set) creates the default media folder object.
 *
 * @param boolean $autocreate
 *   Creates the folder if necessary.
 * @return object|FALSE
 *   The folder term or FALSE if not found.
 */
function media_browser_plus_get_media_root_folder($autocreate = FALSE) {
  $root_folder = FALSE;
  $vocabulary = taxonomy_vocabulary_machine_name_load('media_folders');
  if ($vocabulary) {
    // Fetch the media root term.
    $results = taxonomy_get_term_by_name('Media Root', 'media_folders');
    if (!empty($results)) {
      $root_folder = reset($results);
    }
    elseif ($autocreate) {
      $root_folder = new stdClass();
      $root_folder->name = 'Media Root';
      $root_folder->description = 'default media folder';
      $root_folder->vid = $vocabulary->vid;
      $root_folder->weight = '-10';
      // Save (default folder) term.
      taxonomy_term_save($root_folder);
    }
  }
  return $root_folder;
}

/**
 * Returns default javascript settings.
 */
function media_browser_plus_main_view_javascript_settings() {
  global $base_url;
  // Gather environment data.
  $path = drupal_get_path('module', 'media_browser_plus');
  $url = rtrim(url('', array('absolute' => TRUE)), '/') . '/';
  // Create default settings.
  $settings = array(
    'media_browser_plus' => array(
      'filter_active' => isset($_SESSION['media-filter']),
      'url' => $url,
      'images_url' => $base_url . '/' . $path . '/images/',
      'page' => isset($_GET['page']) ? $_GET['page'] : 0,
      'per_page' => variable_get('media_media_per_page', 30),
      'page_items_per_page' => variable_get('media_page_items_per_page'),
      'folder_management_url' => url('admin/content/file/folder_list'),
      'multiselect' => TRUE,
  // Texts.
      'messages' => array(
        'only_one_selection_allowed' => t('Only one media item may be selected'),
      ),
  // Access settings.
      'folder_dnd_enabled' => media_browser_plus_access('edit file'),
      'manage_folders' => media_browser_plus_access('edit folders'),
      'filter_allowed' => media_browser_plus_access('filter media'),
      'add_files' => media_browser_plus_access('upload media'),
    ),
  );
  return $settings;
}

/**
 * Appends the hidden preview form.
 */
function media_browser_plus_media_preview_form() {
  $header = array(
    array(
      'data' => t('Media Preview'),
      'id' => array('media-preview-label'),
    ),
  );

  $form['preview_actions'] = array(
    'previous' => array(
      '#type' => 'submit',
      '#value' => t('previous'),
      '#attributes' => array('id' => 'previous_preview_item'),
    ),
    'select' => array(
      '#type' => 'submit',
      '#value' => t('Select'),
      '#attributes' => array('id' => 'select_preview_item'),
    ),
    'next' => array(
      '#type' => 'submit',
      '#value' => t('next'),
      '#attributes' => array('id' => 'next_preview_item'),
    ),
  );

  $options = array(
    array(
      'media' => array(
        'data' => '',
        'id' => array('media_browser_plus_preview_content'),
      ),
    ),
    array(
      'media' => array(
        'data' => drupal_render($form['preview_actions']),
        'id' => array('media_browser_plus_preview_panel'),
      ),
    ),
  );

  $table = array(
    'header' => $header,
    'rows' => $options,
    'attributes' => array('id' => 'media-preview-table'),
    'empty' => t('No media added yet.'),
  );

  return array(
    '#type' => 'markup',
    '#markup' => '<div id="media-preview-table-container" style="display: none;">' . theme('table', $table) . '</div>',
    'preview_actions' => $form['preview_actions'],
  );
}

/**
 * Construct the path of a media_folder term.
 *
 * @param object|NULL $term
 *   Containing term id and term name. If left empty the root folder will be
 *   returned.
 *
 * @return string
 *   The path to the requested folder. Doesn't have a trailing slash.
 */
function media_browser_plus_construct_dir_path($term = NULL) {
  $path = variable_get('file_default_scheme', 'public') . '://';
  if ($root_folder = variable_get('media_root_folder')) {
    $path .= $root_folder . '/';
  }
  $root_folder_term = media_browser_plus_get_media_root_folder();
  if ($term) {
    $parents = array_reverse(taxonomy_get_parents_all($term->tid));
    if (is_array($parents) && !empty($parents)) {
      foreach ($parents as $parent) {
        // @TODO Shouldn't we sanitize this?!? There can be special chars!
        $folder_name = $parent->name;
        if ($parent->tid != $root_folder_term->tid) {
          $path .= $folder_name . '/';
        }
      }
    }
  }
  return rtrim($path, '/');
}

/**
 * Cut-paste a directory with its children into a new filesystem location.
 *
 * @param string $source
 *   The current folder path.
 * @param string $destination
 *   The path we want the folder moved to.
 */
function media_browser_plus_move_physical_folder($source, $destination) {
  $destination = drupal_realpath($destination);
  $source = drupal_realpath($source);
  $jail = drupal_realpath(variable_get('file_default_scheme', 'public') . '://');
  // @todo Please avoid an error by checking the preconditions instead.
  $files = @scandir($source);
  if ($files && count($files) > 2) {
    $transfer = new FileTransferLocal($jail);
    $transfer->copyDirectory($source, $destination);
    $transfer->removeDirectory($source);
  }
  else {
    // The folder is empty so just delete and create the new one.
    drupal_rmdir($source);
    file_prepare_directory($destination, FILE_CREATE_DIRECTORY);
  }
  return TRUE;
}

/**
 * Moves and saves permanently a media file.
 *
 * Every media file that is saved or updated,should pass through this to make
 * sure the filesystem location is the same with the folder term.
 *
 * @param int $tid
 *   The folder's term id.
 * @param stdClass $media
 *   The media object.
 * @param int $replace
 *   Replace behavior when the destination file already exists.
 */
function media_browser_plus_move_file($tid, $media, $replace = FILE_EXISTS_RENAME) {
  // Don't change the uri for media files with external source.
  if (strpos($media->uri, 'public') === FALSE && strpos($media->uri, 'private') === FALSE) {
    file_save($media);
  }
  else {
    // Media translation module does need this since it allows the creation of
    // file references which shouldn't move the referenced file itself when
    // moved. See http://drupal.org/node/1331818 for details.
    if (module_exists('media_translation') && media_translation_is_virtual_file($media->fid)) {
      file_save($media);
      return;
    }
    $folder = taxonomy_term_load($tid);
    $path = media_browser_plus_construct_dir_path($folder);
    file_prepare_directory($path, FILE_CREATE_DIRECTORY);
    file_move($media, $path, $replace);
  }
}

/**
 * Implements hook_taxonomy_term_presave().
 *
 * @see media_browser_plus_taxonomy_term_update().
 */
function media_browser_plus_taxonomy_term_presave($term) {
  // Figure out if this is a folder term and if so store the current file path
  // for further processing in media_browser_plus_taxonomy_term_update().
  $vocabulary = taxonomy_vocabulary_machine_name_load('media_folders');
  if (!empty($term->tid) && !empty($vocabulary) && $term->vid == $vocabulary->vid) {
    $term->media_browser_plus_original_path = media_browser_plus_construct_dir_path($term);
  }
}

/**
 * Implements hook_taxonomy_term_insert().
 */
function media_browser_plus_taxonomy_term_insert($term) {
  if ($term->vocabulary_machine_name == 'media_folders') {
    $dir = media_browser_plus_construct_dir_path($term);
    if (file_prepare_directory($dir, FILE_CREATE_DIRECTORY)) {
      drupal_set_message(t('Folder %term_name created successfully', array('%term_name' => $term->name)));
    }
    else {
      drupal_set_message(t('Folder %term_name created successfully as term but failed to create as physical folder.Please do it manually', array('%term_name' => $term->name)), 'warning');
    }
  }
}

/**
 * Implements hook_taxonomy_term_update().
 *
 * @see media_browser_plus_taxonomy_term_presave()
 */
function media_browser_plus_taxonomy_term_update($term) {
  // Check if this is a folder term and the source path is set.
  if (!empty($term->media_browser_plus_original_path)) {
    module_load_include('inc', 'media_browser_plus', '/includes/media_browser_plus.folders');
    // Update physical folder.
    $destination = media_browser_plus_construct_dir_path($term);
    media_browser_plus_move_subfolder($term, $term->media_browser_plus_original_path, $destination);
  }
}

/**
 * Implements hook_taxonomy_term_delete().
 */
function media_browser_plus_taxonomy_term_delete($term) {
  // Figure out if this is a folder term and if so handle the related files.
  $vocabulary = taxonomy_vocabulary_machine_name_load('media_folders');
  if (!empty($vocabulary) && $term->vid == $vocabulary->vid) {
    // Create an array of all the folders to handle.
    $folders = array(
      '0:' . $term->tid => $term,
    );
    // Fetch all sub-folders.
    $tree = taxonomy_get_tree($term->vid, $term->tid);
    foreach ($tree as $subterm) {
      $folders[($subterm->depth + 1) . ':' . $subterm->tid] = $subterm;
    }
    // Ensure the order for processing is right.
    krsort($folders);

    foreach ($folders as $folder) {
      // Fetch all files from the folder.
      $conditions = array();
      $conditions[] = array('field' => array('field_folder', 'tid', $folder->tid, '='));
      $options = array(
        'apply_filter' => FALSE,
        'count_only' => FALSE,
        'paging' => FALSE,
        'conditions' => $conditions,
      );
      $folder_path = media_browser_plus_construct_dir_path($folder);
      if ($files = media_browser_plus_load_multiple($options)) {
        $all_files_deleted = TRUE;
        if (!empty($files->results)) {
          foreach ($files->results as $file) {
            if (!file_delete($file)) {
              $all_files_deleted = FALSE;
            }
          }
        }
        // Also delete the folder when it's empty.
        if ($all_files_deleted) {
          if (!@drupal_rmdir($folder_path)) {
            drupal_set_message(t('Unable to delete the folder (!path) on the disk', array('!path' => $folder_path)), 'error');
          }
        }
      }
    }
  }
}
